---
title: "Manipulação de dados em R"
author: "Leonardo Sangali Barone"
date: "April 03, 2017"
output: pdf_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Manipulação de dados com a gramática básica do pacote dplyr

## Um primeiro exemplo

Nosso primeiro exemplo será a base de dados dos saques efetuados pelos beneficiários do Bolsa Família em janeiro de 2017. Em primeiro lugar, podemos ir ao [portal da transparência](http://www.portaldatransparencia.gov.br/downloads/mensal.asp?c=BolsaFamiliaSacado#exercicios2017).

O arquivo de 2017 contém 1.6Gb. É um arquivo bastante grande, com 14 variáveis (colunas) e mais de 12 milhões de linhas. Arquivos grandes podem ser abertos no R usando a função _fread_, disponível no pacote _data.table_. Num futuro breve veremos o que são funções e pacotes. Por enquanto, basta saber que tornamos as funções de um pacote disponíveis se importarmos o pacote para nossa biblioteca usando a função _library_.

```{r}
library(data.table)
library(dplyr)
```

Vamos agora abrir os dados com a função _fread_, que vimos em tutoriais passados.

```{r}
saques <- fread("201701_BolsaFamiliaSacado.csv")
```

Simples, não? Vamos ver o resultado da importação com a função _head_, que retorna as 6 primeiras linhas do banco de dados:

```{r}
head(saques)
```

Para checar quantas linhas e colunas há nos dados importados, usamos a função _dim_:

```{r}
dim(saques)
```

E observar os nomes das variáveis:

```{r}
names(saques)
```

Nomes com espaços, acentos e caracteres especiais são bastante ruins de se trabalhar. Além disso, há um problema nesse banco de dados: a coluna "Valor Parcela", que contém os valores sacados, não foi lida automaticamente como número. Assim, vamos renomear algumas variáveis (NIS, UF, Mês do saque e código do município, por exemplo), e vamos construir uma nova variável "valor", que contenha números e não números interpretados como texto:

```{r}
saques <- saques %>% 
  rename(nis = `NIS Favorecido`, uf = UF, munic = `Nome Município`, mes = `Mês Referência Parcela`) %>%
  mutate(valor = as.numeric(gsub(",", "", saques$`Valor Parcela`)))
```

Se você prestar atenção no código acima, verá que ele é mais simples do que parece. Ele é um exemplo de como podemos usar o pacote _dplyr_ para manipularmos dados.

Agora que as variáveis têm nomes mais curtos e fáceis de trabalhar e a coluna "valor" foi construída, podemos explorar os dados. Vamos fazer uma tabela de contagem de saques por UF, um histograma com a distribuição dos valores sacados e uma tabela com a soma dos valores por UF.

Primeiro, a tabela que contém a contagem por UF de todos os beneficiários que sacaram em janeiro de 2017:
  
```{r}
saques %>% group_by(uf) %>% summarise(contagem = n())
```

Vejamos agora a distribuição de valores sacados em janeiro de 2017 em um histograma:
  
```{r}
hist(saques$valor, main = "Distribuição dos valores sacados em jan/2017", xlab = "R$", ylab = "Frequência")
```

Legal, não?

Finalmente, vamos fazer o somatório dos valores sacado por UF em 2017:
  
```{r}
saques %>% group_by(uf) %>% summarise(valores = sum(valor))
```

Note que com poucas linhas de código processamos um bocado de dados e geramos informações úteis para a compreensão do programa bolsa família. Em um futuro breve, veremos como organizar, manipular e "misturar" bases de dados volumosas e extrair informações delas.

## Introdução ao pacote dplyr

Um dos aspectos mais incríveis da linguagem R é o desenvolvimento de novas funcionalidades pela comunidade de usuários. Algumas das melhores soluções desenvolvidas são relacionadas à "gramática para bases de dados", ou seja, à maneira como importamos, organizamos, manipulamos e extraímos informações das bases de dados.

Neste tutorial vamos nos concentrar na "gramática" mais popular: o pacote _dplyr_. Já vimos um pouco como ele funciona no exemplo, com dados dos saques do Bolsa Família em janeiro de 2017. Voltemos a este exemplo, mas agora com uma versão mais simples dos dados extraído aleatoriamente do banco original, com apenas 10 mil saques.

```{r}
saques_amostra_201701 <- read_delim()

```

## Renomeando variáveis

Com certa frequência, obtemos dados cujos nomes das colunas são compostos, contêm acentuação, cecedilha e demais caracteres especiais. Dá um tremendo trabalho usar nomes com tais característica. O ideal é termos nomes sem espaço (você pode usar ponto ou subscrito para separar palavras em um nome composto), preferencialmente com letras minísculas sem acento e números, apenas. Vamos começar renomeando algumas variáveis no nosso banco de dados, cujos nomes vemos com o comando abaixo:

```{r}
names(saques_amostra_201701)
```

O primeiro argumento da função _rename_ deve ser a base de dados cujos nomes das variáveis serão renomeados. Depois da primeir vírgula, inserimos todos as modificações de nomes, novamente separadas por vírgulas, e da seguinte maneira. Exemplo: nome\_novo = nome\_velho. Caso os nomes tenha espaço, como no nosso exemplo, é preciso usar o acento agudo antes e depois do nome antigo para que o R entenda onde ele começa e termina. Exemplo: nome|_novo = \`Nome Velho\`. Veja o exemplo, em que damos novos nomes às variáveis "UF" e "Nome Município"

```{r}
saques_amostra_201701 <- rename(saques_amostra_201701, uf = UF, munic = `Nome Município`)
```

## Exercício

Renomeie as variáveis "Código SIAFI Município", "Nome Favorecido", "Valor Parcela", "Mês Competência" e "Data do Saque" como "cod_munic", "nome", "valor", "mes", "data_saque", respectivamente.

## Uma gramática, duas formas

Se voltarmos ao exemplo do começo da apostila, veremos que usamos uma sintaxe ligeiramente diferente para a mesma tarefa, renomear variáveis. Vamos olhar para ela:

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% rename(uf = UF, munic = `Nome Município`)
```
Usando o operador %>%, denominado _pipe_, retiramos de dentro da função _rename_ o banco de dados cujas variáveis serão renomeadas. Essa outra sintaxe tem uma vantagem grande sobre a anterior: ela permite emendar uma operação de transformação do banco de dados na outra. Veremos adiante como fazer isso. Por enquanto, tenha em mente que o resultado é o mesmo para qualquer uma das duas formas.

## Selecionando colunas

Algumas colunas são claramente dispensáveis em nosso banco de dados. Por exemplo, já sabemos que "Código Função", "Código Subfunção", "Código Programa" e "Código Ação" não variam entre as linhas, pois todas se referem ao Programa Bolsa Família. Vamos ficar apenas com as variáveis que já havíamos renomeado.

```{r}
saques_amostra_201701 <- select(saques_amostra_201701, uf, munic, cod_munic, nome, valor, mes, data_saque)
```

ou usando o operador %>%,

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% select(uf, munic, cod_munic, nome, valor, mes, data_saque)
```

Simples, não? Se observarmos as dimensões da nossa base dados, veremos que ela tem 10 mil linhas, mas apenas 7 colunas agora:

```{r}
dim(saques_amostra_201701)
```


## Operador %>% para "emendar" tarefas

Use o comando _rm_ para deletar a base de dados e abra novamente. Vejamos agora como usamos o operador %>% para "emendar" tarefas:

```{r}
saques_amostra_201701 %>% 
  rename(uf = UF, munic = `Nome Município`,
         cod_munic = `Código SIAFI Município`, nome = `Nome Favorecido`,
         valor = `Valor Parcela`, mes = `Mês Competência`, data_saque =`Data do Saque`)  %>%
  select(uf, munic, cod_munic, nome, valor, mes, data_saque)
```

Em uma única sequência de operações, alteramos os nomes das variáveis e selecionamos as que permaneceriam no banco de dados. Esta forma de programa, tenha certeza, é bastante mais econômica.

## Transformando variáveis

Vimos no exemplo que a variável valor, apesar de conter números, foi lida como texto. Isso ocorre por que o R não entende o uso da vírgula como separador de mlhar. Como resolver um problema desses?

Usaremos a função _mutate_ para operar transformações nas variáveis existentes e criar variáveis novas. Há inúmeras transformações possíveis e elas lembram bastante as funções de outros softwares, como MS Excel. Vamos ver algumas das mais importantes.

Um exemplo simples: vamor gerar uma nova variável com os nomes dos beneficiários em minúsculo usando a função _tolower_. Veja:

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% mutate(nome_min = tolower(nome))
```

ou, em uma forma alternativa,

```{r}
saques_amostra_201701 <-  mutate(saques_amostra_201701, nome_min = tolower(nome))
```

Use o comando View para visualizar o resultado da coluna criada à direita do banco de dados. Simples, não? Basta inserimos dentro do comando mutate a expressão da transformação que queremos.

Vamos a um exemplo um pouco mais difícil: substituir vírgula por vazio em um texto e, a seguir, indicar que o texto é, na verdade, um número. Em vez de criar uma nova variável "valor", vamos apenas alterar a variável já existente duas vezes. Com a função _gsub_, faremos a substituição da vírgula por vazio e com a função _as.numeric_ faremos a transformação texto-número.

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% 
  mutate(valor = gsub(",", "", valor)) %>% 
  mutate(valor = as.numeric(valor))
```

A operação reversa a _as.numeric_, que transforma número em texto, é _as.character_.

Precisamos usar _mutate_ duas vezes? Não. Bastaria separa cada transformação por uma vírgula dentro de cada _mutate_. Vamos ver um novo exemplo. Faremos agora duas operações separadas, cada uma resultando em uma nova variável: dividiremos o valor por 3.2 para transformar o valor em dólares; e somaremos R$ 10 ao valor, pelo simples exercício de ver a transformação.

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% 
  mutate(valor_dolar = valor / 3.2, valor10 = valor + 10)
```

Use o comando _View_ para ver as novas variáveis no banco de dados.

As operações de soma, subtração, divisão, multiplicação, módulo entre mais de uma variável ou entre variáveis e valores são válidas e facilmente executadas como acima mostramos.

Nem todas as transformações de variáveis, porém, são operações matemáticas. Vamos transformar a variável valor em uma nova variável que indique se o valor sacado é "Alto" (acima de R\$ 300) ou "Baixo" (abaixo de R\$ 500) com o comando _cut_:

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% 
  mutate(valor_categorico = cut(valor, c(0, 300, Inf), c("Baixo", "Alto")))
```

E se quisermos recodificar uma variável de texto? Por exemplo, vamos examinar a variável "mes". Ela contém o "Mês de Competência" do saque. Usemos a função _table_ para examiná-la:

```{r}
table(saques_amostra_201701$mes)
```

São 3 valores possíveis em nossa amostra: "11/2016", "12/2016" e "01/2017" em nossa amostra. Vamos gerar uma nova variável, ano, que indica apenas se a competência é 2016 ou 2017. Vamos começar fazendo uma cópia da variável original e depois substituiremos cada um dos valores:

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% 
  mutate(ano = mes,
         ano = replace(ano, ano == "11/2016", "2016"),
         ano = replace(ano, ano == "12/2016", "2016"),
         ano = replace(ano, ano == "01/2017", "2017"))
```

Um pouco trabalhoso, mas cumpre o objetivo. Uma maneira mais inteligente é usar o comando _recode_:

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% 
  mutate(ano = recode(mes, "11/2016" = "2016", "12/2016" = "2016", "01/2017" = "2017"))
```

Com as operações matemáticas, as transformações _as.numeric_ e _as.character_ e os comandos _cut_, _replace_ e _recode_ podemos fazer praticamente qualquer recodifição de variáveis que envolva texto e números. A exceção, por enquanto, serão as variáveis da classe _factor_, que veremos em momento oportuno na leitura do livro base do curso. Para os interessados em expressões regulares, recomendo a leitura do arquivo "help" da família da função _gsub_, que inclui _grep_, _regexpre_ e outras.

## Exercício

Use os exemplos acima para gerar novas variáveis conforme instruções abaixo:

- Faça uma nova divisão da variável "valor" a seu critério. Chame a nova variável de "valor\_categorico2".
- Cria uma variável "valor_euro", que é o valor calculado em Euros.
- Recodifique "valor\_categorico" chamando as categorias de "Abaixo de R\$300" e "Acima de R\$300". Chame a nova variável de "valor\_categorico3".
- Usando a função _recode_ Recodifique "mes" em 3 novos valores: "Novembro", "Dezembro" e "Janeiro". Chame a nova variável de "mes\_novo".
- Usando a função _replace_ Recodifique "mes" em 3 novos valores: "Novembro", "Dezembro" e "Janeiro". Chame a nova variável de "mes\_novo2".

## Filtrando linhas

Por vezes, queremos trabalhar apenas com um conjunto de linhas do nosso banco de dados. Por exemplo, se quisermos selecionar apenas os beneficiários do estado do Espírito Santo e salvarmos em um objeto chamado saques_amostra_ES:

```{r}
saques_amostra_ES <- saques_amostra_201701 %>% filter(uf == "ES")
```
ou 

```{r}
saques_amostra_ES <-filter(saques_amostra_201701, uf == "ES")
```

Até o uso da função _filter_, não há nada de novo para nós. A novidade está na condição uf == "ES", que indica que apenas as linhas cuja variável _uf_ assumo valor igual a ES devem ser consideradas. Em primeiro lugar, qual é a razão de usarmos duas vezes o sinal de igualdade (==)? Normalmente, usamos um igual para atribuir algo a um nome ou para definir algo igual a um valor. Neste caso, estamos comparando duas coisas, ou seja, estamos verificando se o conteúdo de cada linha é igual a um valor.

Além da igualdade, poderíamos usar outros símbolos: maior (>). maior ou igual (>=), menor (<), menor ou igual (<=) e diferente (!=).

Também utilizamos aspas em "ES". Como estamos comparando os valores para cada linha a um texto, devemos usar as aspas.

Vamos supor agora que apenas os estados do Centro-Oeste nos interessam. Vamos criar um novo _data frame_, chamado saques_amostra_CO, que atenda a este critério:

```{r}
saques_amostra_CO <- saques_amostra_201701 %>% 
  filter(uf == "MT" | uf == "MS" | uf == "Df" | uf == "GO")
```

Note que, para dizer que queremos as quatro condições atendidas, utilizamos uma barra vertical. A barra é o símbolo "ou", e indica que todas as observações que atenderem a uma ou outra condição serão incluídas.

Vamos supor que queremos estabelecer agora condições para a seleção de linhas a partir de duas variáveis. Por exemplo, queremos incluir observações do Mato Grosso e que também tenham ano de competência (variável que criamos acima) igual a 2016. O símbolo da conjunção "e" é "&". Veja como utilizá-lo:

```{r}
saques_amostra_MT_2016 <- saques_amostra_201701 %>% filter(uf == "MT" & ano == "2016")
```

Você pode combinar quantas condições precisar. Se houver ambiguidade quanto à ordem das condições, use parênteses das mesma forma que usamos com operações aritméticas.

## Exercício

- Crie um novo _data frame_ apenas com as observações cujo mês de competência é janeiro.
- Crie um novo _data frame_ apenas com as observações cujo valor é superior a R\$ 500.
- Crie um novo _data frame_ apenas com as observações da região Sul.

## Agrupando

Por enquanto, por mais que transformássemos as variáveis do banco de dados ou selecionássemos linhas, as unidades continuavam a ser os saques realizados por cada beneficiário. E se, no entanto, nos interessar trabalhar no nível mais agregado? Voltemos ao exemplo 1 do início da apostila.

Vamos começar produzindo um novo _data frame_, mas que agora contenha a informação de quantos saques foram realizados em cada UF:

```{r}
contagem_uf <- saques_amostra_201701 %>% 
  group_by(uf) %>% 
  summarise(contagem = n())
```

Veja que usamos simultaneamente 2 funções, _group\_by_ e _summarise_. Eles tem significado literal: na primeira, inserimos as variáveis pelas quais agruparemos o banco de dados. Na segunda, as operações de "sumário", ou seja, de condensação, que faremos com o banco de dados e com as demais variáveis. No exemplo acima, apenas contamos, usando a função n(), quantas linhas pertencem a cada uf, que é a variável de grupo.

Vamos complicar um pouco mais. Suponhamos que, além da contagem, tenhamos interesse na soma, média, mediana, desvio padrão, mínimo, máximo dos valores no mesmo resultado. Neste caso, devemos inserir novas operações na função _summarise_, separadas por vírgula:

```{r}
valores_uf <- saques_amostra_201701 %>% 
  group_by(uf) %>% 
  summarise(contagem = n(),
            soma = sum(valor),
            media = mean(valor),
            mediana = median(valor),
            desvio = sd(valor),
            minimo = min(valor),
            maximo = max(valor))
```

Use _View_ para observar o resultado.

## Exercício

Usando a variável "mes_novo", calcule a contagem, soma e média de valores para cada mês.

## Mais de um grupo

E se quisermos agrupar por mais de uma variável? Veja como fazer um agrupamento por "mes"" e "uf", reportando apenas a contagem de saques em cada combinação de grupos:

```{r}
contagem_uf_mes <- saques_amostra_201701 %>% 
  group_by(uf, mes) %>% 
  summarise(contagem = n())
```

Note que, agora, cada uf é repetida duas ou três vezes, uma para cada mês. Cada grupo gera uma nova coluna e as linhas representam exatamente a combinação de grupos de cada variável presente nos dados.

Finalmente, podemos utilizar múltiplas variáveis de grupo em conjunto e também gerar um sumário com diversas varáveis, como no exemplo a seguir, que combina parte dos dois anteriores:

```{r}
valores_uf_mes <- saques_amostra_201701 %>% 
  group_by(uf, mes) %>% 
  summarise(contagem = n(),
            soma = sum(valor),
            media = mean(valor),
            desvio = sd(valor))
```

## Novo _data frame_ ou tabela para análise?

O uso das funções _group\_by_ e _summarise_ pode ter 2 propósitos: produzir uma tabela para análise, como fizemos acima, ou gerar um novo _data frame_. Basicamente, os usos dependem do tamanho redução que geramos no banco de dados. Por exemplo, podemos gerar os totais de valores transferidos para cada município (que, se tivessemos o banco completo, geraria um banco de aprox 5,5 mil linhas) para, a seguir, inserí-lo nos dados originais como coluna. Por enquanto, ainda não aprendemos a relacionar dois _data frames_ entre si, mas vejamos como seria a base de dados com municípios como linhas:

```{r}
saques_amostra_munic <- saques_amostra_201701 %>% 
  group_by(munic) %>% 
  summarise(contagem = n(),
            soma = sum(valor),
            media = mean(valor))
```

## Ordenando a base de dados

Quando trabalhamos com bases de dados muito grandes, faz pouco sentido ordená-las. Entretanto, quando trabalhamos numa escala menor, com poucas linha, como nos exemplos acima, convém ordenar a tabela (veja que, neste ponto, faz pouco sentido diferenciar tabela de _data frame_, pois tornam-se sinônimos) por alguma variável de interesse.

Se quisermos ordenar, de forma crescente, a tabela de valores por uf pela soma de valores, basta usar o comando _arrange_:

```{r}
valores_uf <- valores_uf %>% arrange(soma)
```

Apenas para ilustrar, poderíamos ter usado o comando _arrange_ diretamente ao gerar a tabela:

```{r}
valores_uf <- saques_amostra_201701 %>% 
  group_by(uf) %>% 
  summarise(contagem = n(),
            soma = sum(valor),
            media = mean(valor),
            mediana = median(valor),
            desvio = sd(valor),
            minimo = min(valor),
            maximo = max(valor)) %>%
  arrange(soma)
```

Se quisermos rearranjar uma tabela, agora em ordem decrescente de média de valores, por exemplo, usamos _desc_:

```{r}
valores_uf <- valores_uf %>% arrange(desc(soma))
```

Para usar mais de uma variável ao ordenar, basta colocá-las em ordem de prioridade e separá-las por vírgula. No exemplo abaixo ordenamos pela mediana (descendente) e depois pelo máximo:

```{r}
valores_uf <- valores_uf %>% arrange(desc(mediana), maximo)
```

## Paramos por aqui

Neste tutorial, cobrimos as operações básicas de manipulação dos dados. No próximo tutorial trabalharemos com as transformações do banco de dados que produzem agrupamentos a partir de variáveis de grupo. Vamos seguir utilizando as variáveis geradas neste tutorial.

\pagebreak

# Tutorial 3 - Uma gramática para bases de dados - parte 2

Até agora, partimos de uma única base de dados e fizemos diversas transformações: mudamos de nomes de variáveis, computamos novas variáveis, selecionamos linhas e colunas, agrupamos e ordenamos. A partir de agora vamos aprender a combinar _data frames_ proveninentes de fontes diferente.

# Comparação dos pagamentos entre janeiro de 2011 e janeiro de 2017 no Programa Bolsa Família

No lugar de uma amostra dos dados, como no tutorial anterior, utilizaremos no começo deste tutorial os dados de pagamento do Programa Bolsa Família em um município de pequeno porte: Borá, cidade do interior de São Paulo.

Vamos começar importando os dados do mês de janeiro de cada um dos anos.

Veja que os dados são semelhantes e têm a mesma estrutura. Esperamos, entretanto, que haja variação entre os anos e que os beneficiários e os valores pagos não sejam os mesmos, seja por que as pessoas entraram e saíram do programa ao longo do tempo, seja por que mudaram de município, seja por que os valores sofreram alteração em virtude de reajuste e mudanças na estrutura das famílias.

Como descobrir tais mudanças? Como saber quem estava em 2011 e também em 2017? Como calcular a variação dos valores para cada beneficiário?

## Exercício

Examine as bases de dados "pagamentos11" e "pagamentos17" antes de começarmos a trabalhar com elas. Faça também as seguintes alterações:

- Renomeie as variáveis "NIS Favorecido", "Nome Favorecido" e "Valor Parcela" para "nis", "nome" e "valor", repectivamente.
- Transforme a variável valor em numérica.
- Selecione apenas as três variáveis renomeadas.
- Quantas linhas tem cada base de dados?

## Resposta parcial ao exercício anterior (3 primeiros itens)

```{r}
# 2011
pagamentos11 <- pagamentos11 %>% 
  rename(nis = `NIS Favorecido`, nome = `Nome Favorecido`, valor = `Valor Parcela`) %>%
  mutate(valor = gsub(",", "", valor), valor = as.numeric(valor)) %>%
  select(nis, nome, valor)

# 2017
pagamentos17 <- pagamentos17 %>% 
  rename(nis = `NIS Favorecido`, nome = `Nome Favorecido`, valor = `Valor Parcela`) %>%
  mutate(valor = gsub(",", "", valor), valor = as.numeric(valor)) %>%
  select(nis, nome, valor)
```

## Left e Right Join

Tendo as bases preparadas e sabendo que os beneficiários variam entre os anos, podemos começar a "juntá-las".

O elemento essencial dos "joins", ou seja, das combinações de bases de dados, é que haja uma variável que associe observações em uma base com observações em outras. Algumas variáveis costumam ser candidatas naturais para tal tarefa: CPF, NIS e Título de Eleitor, para indíduos e Código de município e UF para unidades político-administrativas. Mas, veremos adiante, podemos ser criativos e utilizar diversas outras "chaves" para conectar tabelas. O identificador que temos disponível em nossos dados é o NIS.

"Letf join" e "right join" são os nomes dados às combinações que mantém todas as linhas de uma das bases de dados, mesmo sem haver correspondente na outra tabela, e inclui apenas os dados da segunda base que encontram correspondência na primeira tabela.

Vamos operar os dois "joins" e ver o que ocorre. Primeiro, "left join":

```{r}
comb_left <- left_join(pagamentos11, pagamentos17, by = "nis")
```

Veja que informamos ao R que a variável que conecta as tabelas é "nis" informando o parâmetro "by".

Quantas linhas resultaram da combinação? Exatamente o mesmo número de linhas de "pagamentos11". Use o _View_ para ver o resultado.

Note que há duas variáveis de valor, uma com final ".x" e outra com o final ".y". Isso ocorre por que as duas bases tem os mesmos nomes de variáveis. ".x" significa que a variável veio da primeira tabela do "join" e ".y", da segunda. O mesmo ocorre com a variável "nome". Vamos aproveitar e renomeá-las:

```{r}
comb_left <- comb_left %>% rename(valor11 = valor.x, nome11 = nome.x, 
                                  valor17 = valor.y, nome17 = nome.y)
```

Note que em diversas observações o valor e o nome para 2017 contém "NA", que é o símbolo do R para "missing values". O que isso significa? Significa que aquela observações existia em 2011, mas não em 2017. Ao não encontrar correspondência, o R manteve a observação, mas não inseriu nenhum valor.

Se o número de linhas da combinação é o mesmo de 2011, onde estão as observações de 2017 que faltam? Não foram incluídas. O "left join" garante que todas as observações de 2011 sejam mantidas, mesmo sem correspondência, mas exclui todas as observações de 2017 que não encontrem par em 2011.

Vamos deixar de lado rapidamente esta primeira combinação e realizar o "right join" das mesmas tabelas:

```{r}
comb_right <- right_join(pagamentos11, pagamentos17, by = "nis")
```

Novamente, vamos renomear as variáveis:

```{r}
comb_right <- comb_right %>% rename(valor11 = valor.x, nome11 = nome.x, 
                                    valor17 = valor.y, nome17 = nome.y)
```

Veja que agora há "missing values" nos valores e nomes de 2011. O "right join" preserva todas as observações de 2017, mesmo sem correspondência em 2011, e não inclui nenhum de 2011 que não encontre correspondência.

Note que "left" e "right" são exatamente a mesma operação, mas com as tabelas em posição (x e y, 1a e 2a, etc) invertidas.

## Inner e Full Join

E se quisermos apenas as observações que estão, com certeza, em ambos os anos? Usamos o "inner join". Veja o resultado (já renomeado):

```{r}
comb_inner <- inner_join(pagamentos11, pagamentos17, by = "nis")
comb_inner <- comb_inner %>% rename(valor11 = valor.x, nome11 = nome.x, 
                                    valor17 = valor.y, nome17 = nome.y)
```

Agora, não há "missing values". Permanecem na combinação apenas os casos que estão presentes em ambas tabelas.

Finalmente, o "full join" adota o critério oposto: inclui todas as observações de ambos tabelas, não importando se há ou não correspondência, e insere "missing values" onde não há correspondência:

```{r}
comb_full <- full_join(pagamentos11, pagamentos17, by = "nis")
comb_full <- comb_full %>% rename(valor11 = valor.x, nome11 = nome.x, 
                                  valor17 = valor.y, nome17 = nome.y)
```

## Semi e anti joins

Os quatro tipos de "join" apresentados anteriormente cobrem a totalidade de situações de combinação entre tabelas a partir de um "chave", ou seja, de um índice ou variável que permita estabelecer a relação entre elas.

Há, porém, dois outros tipos de "joins" disponíveis no R bastante úteis.

Se quisermos trabalhar apenas em uma única base de dados, por exemplo, pagamentos11, mas queremos saber quais das observações de 2011 também estão na tabela de 2017, então utilizamos a função _semi\_join_. O resultado será semelhante ao da aplicação de _inner\_join_, mas sem que novas colunas com os dados de 2017 tenham sido criadas:

```{r}
comb_semi <- semi_join(pagamentos11, pagamentos17, by = "nis")
```

Por fim, _anti\_join_, tem comportamento semelhante a _semi\_join_, mas, em vez de retornar as observações de 2011 que têm correspondência em 2017, retorna as que nâo têm par em 2017:

```{r}
comb_anti <- anit_join(pagamentos11, pagamentos17, by = "nis")
```

É perfeitamente possível usar o operador %>% (pipe, como é chamado), para os "joins". Basta colocar a base na posição "x" (primeira a ser inserida) antes do operador. Veja um exemplo:

```{r}
comb_left <- pagamentos11 %>% left_join(pagamentos17, by = "nis")
```

## Exercício

Respire fundo e gaste um tempo refletindo sobre os "joins". Você acabou de aprender como operar bancos de dados relacionais e pode parecer bastante difícil num primeiro momento.

bind_cols
bind_rows

## Combinação de tabela e agregações cumulativas

Vamos supor que queremos calcular os valores total, médio, máximo, etc, por município e, a seguir, apresentar esses valores como colunas para cada observação. Uma maneira eficiente de fazer isso é a usando a combinação de tabelas. Vamos er como voltando ao exemplo da amostra de saques do Programa Bolsa Família em 2017.

## Exercício

Abra a base de dados e faça as transformações necessárias (renomear variáveis e transformar a variável valor em numérica) antes de prosseguir.

## Pasos para agregações cumulativas

Em primeiro lugar, vamos construir uma tabela agrupada por município usando _group\_by_ e _summarise_:

```{r}
valores_munic <- saques_amostra_201701 %>% 
  group_by(cod_munic) %>% 
  summarise(contagem = n(),
            soma = sum(valor),
            media = mean(valor),
            mediana = median(valor),
            desvio = sd(valor),
            minimo = min(valor),
            maximo = max(valor))
```

Note que agora temos dois _data frames_, o original e "valores_munic", que pode ser combinados utilizando a variável "cod_munic". Usando _left\_join_ podemos levar as colunas da nova tabela à base de dados original:

```{r}
saques_amostra_201701 <- saques_amostra_201701 %>% left_join(valores_munic, by = "cod_munic")
```

Use _View_ para observar que a base de dados original tem agora 7 novas colunas com informações agregadas por município (e que, portanto, se repetem para observações de um mesmo município).

# Exercício

- Calcule o total de valores por UF em um novo _data frame_.
- Combine o novo _data frame_ com o original para levar a coluna de total de valores ao último.
- A seguir, calcule quanto cada indivíduo na amostra representa, em termor percentuais (dica: crie uma nova variável utilizando _mutate_).

\pagebreak
